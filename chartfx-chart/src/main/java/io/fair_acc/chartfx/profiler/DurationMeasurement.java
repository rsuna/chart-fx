package io.fair_acc.chartfx.profiler;

import java.util.Locale;
import java.util.function.Consumer;
import java.util.function.LongSupplier;

/**
 * Gets called before and after an action. May record time.
 *
 * @author ennerf
 */
public interface DurationMeasurement {

    /**
     * Called when an action begins. Sets the start timestamp.
     *
     * @return start time in the used clock
     */
    long start();

    /**
     * Called when an action is done. Records delta from the start timestamp.
     *
     * @return end time in the used clock
     */
    long stop();

    /**
     * Records the delta from now to the specified start time generated by this measurement.
     *
     * @return end time in the used clock
     */
    long stop(long startTime);

    /**
     * A default implementation that does nothing and results in no overhead
     */
    public static final DurationMeasurement DISABLED = new DurationMeasurement() {
        @Override
        public long start() {
            return 0;
        }

        @Override
        public long stop() {
            return 0;
        }

        @Override
        public long stop(long startTime) {
            return 0;
        }
    };

    /**
     * Base implementation for keeping time using a specifiable clock
     */
    public abstract static class AbstractDurationMeasurement implements DurationMeasurement {

        protected AbstractDurationMeasurement() {
            this(System::nanoTime);
        }

        protected AbstractDurationMeasurement(LongSupplier clock) {
            this.clock = clock;
        }

        @Override
        public long start() {
            return startTime = clock.getAsLong();
        }

        @Override
        public long stop() {
            return stop(startTime);
        }

        @Override
        public long stop(long startTime) {
            if (startTime == INVALID_START_TIME) {
                throw new IllegalStateException("Invalid start time. start() must be called before stop()");
            }
            final long endTime = clock.getAsLong();
            recordDuration(endTime - startTime);
            startTime = INVALID_START_TIME;
            return endTime;
        }

        protected abstract void recordDuration(long duration);

        final LongSupplier clock;
        long startTime = INVALID_START_TIME;
        protected static final int INVALID_START_TIME = -1;

    }

    /**
     * A debug implementation that prints start and stop strings with duration information
     */
    public static final class MeasurementDebugPrinter extends AbstractDurationMeasurement {

        public MeasurementDebugPrinter(String tag, Consumer<String> logger) {
            super(System::nanoTime);
            this.tag = tag;
            this.logger = logger;
            this.startString = tag + " - started";
            this.stopTemplate = tag + " - finished (%.2f ms)";
        }

        @Override
        public long start() {
            logger.accept(startString);
            return super.start();
        }

        @Override
        protected void recordDuration(long duration) {
            logger.accept(String.format(Locale.ENGLISH, stopTemplate, duration * 1E-6));
        }

        final String tag;
        final Consumer<String> logger;
        final String startString;
        final String stopTemplate;

    }

}
